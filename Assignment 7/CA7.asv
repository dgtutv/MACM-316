%Define our mathematical functions
f0 = @(x) x.^3;
f1 = @(x) sin(0.5*x);
f2 = @(x) abs(sin(2*x));
f3 = @(x) cos(x);
%Define our intervals
I1 = [0, pi/3];
I2 = [0, 2*pi];
%Store the actual integral's values in a vector, where index 1 is for interval I1, and index 2 is for interval I2
truef1 = [2-sqrt(3), 4];
%Compute approximation of functions
y0 = trapezoidrule(f0, 0, 1, 100); %Test case with fixed a, b, N
disp(y0); %Show the value of the test case, should converge to 1/4

outputf1 = approximateIntegral(f1, I1, I2);
disp(f1(1,:));
disp(f1(2,:));
disp(f1(3,:));

%Define out computational functions
function output = approximateIntegral(f, I1, I2)
    output = [];
    for N=1:100:1000 %f1
        output(1,end+1) = N;
        output(2,end+1) = trapezoidrule(f, I1(1), I1(2), N); %Should converge to 2-root(3) = 0.2679491924311227
        output(3,end+1) = trapezoidrule(f, I2(1), I2(2), N); %Should converge to 4
    end
end
%NOTE:
    %I defined my outputs in the function such that the columns are for differing outputs from our N values, and the rows are for
    %intervals I1, I2, except the first row which stores the N values
                               %[N0    , N1    , ... ,Nj    ]
        %for example: outputf = [f'(N0), f'(N1), ... ,f'(Nj)] for I1
                               %[f'(N0), f'(N1), ... ,f'(Nj)] for I2